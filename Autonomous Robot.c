#pragma config(Sensor, in2, IRsensor, sensorReflection)
#pragma config(Sensor, dgtl1, button1, sensorTouch)
#pragma config(Sensor, dgtl2, sonar, sensorSONAR_cm)
#pragma config(Sensor, dgtl4, button2, sensorTouch)
#pragma config(Sensor, dgtl5, lever1, sensorTouch)
#pragma config(Sensor, dgtl6, lever2, sensorTouch)
#pragma config(Sensor, dgtl12, GreenLED, sensorDigitalOut)
#pragma config(Motor, port1, motor_right, tmotorVex393_HBridge, openLoop, driveRight)
#pragma config(Motor, port2, motor_left, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor, port10, motor_placement, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int IR_SENSOR_THRESHOLD_FAR = 10;    // Defines a threshold value for the infrared sensor indicating the presence of an object at a distance far away from the robot.
const int IR_SENSOR_THRESHOLD_CLOSE = 165; // Defines a threshold value for the infrared sensor indicating the presence of an object at a distance close to the robot.

// The following functions control the movement of the robot:

void drive_forward()
{                            // Defines a function to move the robot forward.
    motor[motor_right] = 50; // Sets the speed of  right motor to 50
    motor[motor_left] = 31;  // Sets the speed of  left motor to 31
}

void drive_backwards()
{                             // Defines a function to move the robot backwards.
    motor[motor_right] = -40; // Sets the speed of  right motor to -40(negative value indicates reverse).
    motor[motor_left] = -22;  // Sets the speed of left motor to -22(negative value indicates reverse).
}

void motor_stop()
{                                               // Defines a function to stop the robot.
    motor[motor_right] = motor[motor_left] = 0; // Sets the speed of both motors to 0
}

void rotate_right()
{                            // Defines a function to rotate the robot to the right.
    motor[motor_right] = 50; // Sets the speed of  right motor1 to 50 .
    motor[motor_left] = -30; // Sets the speed of  left motor to -30(negative value indicates opposite direction).
}

void IRsense_far()
{ // Defines a function to detect objects at a far distance using the infrared sensor.

    rotate_right(); // Rotates the robot to the right.

    // Declare variables to store the IR sensor readings
    int IR_reading1;
    int IR_reading2;

    while (1)
    {

        IR_reading1 = SensorValue(IRsensor); // Reads the infrared sensor and stores the first reading in IR_reading1.
        wait1Msec(75);                       // Pauses for 75 milliseconds.
        IR_reading2 = SensorValue(IRsensor); // Reads the infrared sensor again and stores the second reading in IR_reading2.

        // Checks if either of two levers on the robot has been triggered (hit wall), drives backwards for 500 milliseconds, and then rotates the robot to the right.
        if (SensorValue(lever1) == 1 || SensorValue(lever2) == 1)
        {

            motor_stop();

            drive_backwards();
            wait1Msec(500);

            rotate_right();

        }

        int difference = IR_reading1 - IR_reading2; // Calculates the difference between the two infrared sensor readings.

        // If the difference between the two infrared sensor readings exceeds the threshold value for objects far away then Robot has found the target
        if (difference > IR_SENSOR_THRESHOLD_FAR || difference < -IR_SENSOR_THRESHOLD_FAR)
        {

            motor_stop(); // stops motor
            break;

        }
    }
}

void IRsense_close()
{

    // Rotate the robot to the right using the rotate_right function
    rotate_right();

    // Declare variables to store the IR sensor readings
    int IR_reading1;
    int IR_reading2;

    while (1)
    {

        // Read the IR sensor values and store them in the variables
        IR_reading1 = SensorValue(IRsensor);
        wait1Msec(75);
        IR_reading2 = SensorValue(IRsensor);

        // Checks if either of two levers on the robot has been triggered (hit wall), drives backwards for 500 milliseconds, and then rotates the robot to the right.
        if (SensorValue(lever1) == 1 || SensorValue(lever2) == 1)
        {

            motor_stop();

            drive_backwards();
            wait1Msec(500);

            rotate_right();
        }

        // Calculate the difference between the IR sensor readings
        int difference = IR_reading1 - IR_reading2;

        // Check if the difference is greater than or less than the close threshold, if it is then robot has located target again from close range
        if (difference > IR_SENSOR_THRESHOLD_CLOSE || difference < -IR_SENSOR_THRESHOLD_CLOSE)
        {

            // Stop the motors and break out of the loop
            motor_stop();
            break;

        }
    }
}



void placement()
{

    wait1Msec(500);              // Wait for half a second
    motor[motor_placement] = 13; // Move motor_placement forward slowly to make placement easier

    wait1Msec(2500);             // Wait for 2.5 seconds for the object to be placed
    motor[motor_placement] = 25; // Increase the speed of motor_placement so it rotates enough so the arm doesnt hit ball when reversing out

    wait1Msec(200);              // Wait for 0.2 seconds
    motor[motor_placement] = 0;  // Stop motor_placement arm from rotating

}

void wall_detection()
{

    // Drive forward until a wall is detected or a lever is triggered
    while (SensorValue(sonar) > 30 && SensorValue(lever1) == 0 && SensorValue(lever2) == 0)
    {

        drive_forward();

    }

    motor_stop(); // Stop the motors if a wall or a lever is detected

}





// Function for robot to find side of arena after it has succesfully placed the ball
void exit()
{

    // Drive backwards for 0.9 seconds
    drive_backwards();
    wait1Msec(1200);

    // Stop the motors
    motor_stop();

    // Rotate right for 3.3 seconds
    rotate_right();
    wait1Msec(3300);

    // Detect the wall
    wall_detection();


    // Turn on the green LED
    SensorValue(GreenLED) = 1;

    // Move the arm back to its original position after ball was placed
    motor[motor_placement] = -30;
    wait1Msec(650);
    motor[motor_placement] = 0;

    // Turn off the green LED
    SensorValue(GreenLED) = 0;
}

task main()
{

    SensorValue(GreenLED) = 0; // turn off the green LED

    while (1)
    {

        if (SensorValue(button1))
        { // if button 1 is pressed

            while (SensorValue(sonar) > 15 && SensorValue(lever1) == 0 && SensorValue(lever2) == 0)
            { // while the robot is far from the wall and no levers are triggered

                wait1Msec(1000); // wait for 1 second

                IRsense_far(); // Spin until the IR sensor detects the target

                while (SensorValue(sonar) > 40 || SensorValue(sonar) == 12 || SensorValue(sonar) == 13 )
                { // while the robot is greater than 40cm from the target and reading is valid, had to add statememts due to an error where sonar sensor would detect ball and wreck detection process

                    drive_forward(); // move forward

                }


                motor_stop(); // stop moving
                wait1Msec(500); // wait for 500ms

                rotate_right();

                wait1Msec(1000);

                IRsense_close(); // soin until the IR sensor readings show the robot is aligned with target

                wait1Msec(500); // wait for 500ms

                while (SensorValue(sonar) > 11 && SensorValue(sonar) > 0)
                { // while the robot is not too close to the target and the sonar reading is valid

                    drive_forward(); // move forward

                }

                motor_stop(); // stop moving

                wait1Msec(200); // wait for 200ms

                placement(); // place the ball on top of the target

                exit(); // move to the side of the arena and stop the robot
                break;  // exit the while loop

            }
        }
    }
}
